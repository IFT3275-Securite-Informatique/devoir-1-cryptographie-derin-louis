def expoMod(base, exponent, modulus):
    result = 1
    base = base % modulus
    while exponent > 0:
        if (exponent % 2 == 1):
            result = (result * base) % modulus
        exponent = exponent >> 1
        base = (base * base) % modulus
    return result

def inverseModulaire(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = inverseModulaire(b % a, a)
        return (g, x - (b // a) * y, y)

def inverseMulti(a, m):
    g, x, y = inverseModulaire(a, m)
    if g != 1:
        raise Exception("Problème")
    else:
      return x % m
    
def listeDeInt(x):
    if x < 0:
        return "Impossible"
    
    z = []
    while x > 0:
        z.append(x % 256)
        x = x // 256
    z.reverse() 
    return z


def intEnSTR(x):
    x = listeDeInt(x)
    
    resultat = ''.join(chr(a) for a in x)
    return resultat



# Clé publique Question 1.2
N = 172219604291138178634924980176652297603347655313304280071646410523864939208855547078498922947475940487766894695848119416017067844129458299713889703424997977808694983717968420001033168722360067307143390485095229367172423195469582545920975539060699530956357494837243598213416944408434967474317474605697904676813343577310719430442085422937057220239881971046349315235043163226355302567726074269720408051461805113819456513196492192727498270702594217800502904761235711809203123842506621973488494670663483187137290546241477681096402483981619592515049062514180404818608764516997842633077157249806627735448350463
e = 173


# Calculee a l'exterieur du programme en utilisant la site web Alpertron ECM
phi_n = 172219604291138178634924980176652297603347655313304280071646410523864939208855547078498922947475940487766894695848119416017067844129458299713889703424997977808694983717968420001033168722360067307143390485095229367172423195469582545920975539060699530956357494837243598213416944408434967474317474605697877889098163920627695719815858922891793185119589332706163221475333904450077179164663744310250015655008615246996517684525862514095355962851504256356566158324225875389766063265043069286975838742808788301681907930054018726243233987062721678655183869856893976827414548161578691558498025688839533486731608560

# Cryptogramme 1.2
C = 25782248377669919648522417068734999301629843637773352461224686415010617355125387994732992745416621651531340476546870510355165303752005023118034265203513423674356501046415839977013701924329378846764632894673783199644549307465659236628983151796254371046814548224159604302737470578495440769408253954186605567492864292071545926487199114612586510433943420051864924177673243381681206265372333749354089535394870714730204499162577825526329944896454450322256563485123081116679246715959621569603725379746870623049834475932535184196208270713675357873579469122917915887954980541308199688932248258654715380981800909

d = inverseMulti(e, phi_n)
M = expoMod(C, d, N)
print(intEnSTR(M))